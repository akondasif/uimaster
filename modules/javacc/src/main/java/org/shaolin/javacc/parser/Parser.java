/* Generated By:JavaCC: Do not edit this line. Parser.java */
package org.shaolin.javacc.parser;

import java.io.StringReader;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import org.shaolin.bmdp.utils.StringUtil;
import org.shaolin.javacc.exception.ParsingException;
import org.shaolin.javacc.statement.AssertStatement;
import org.shaolin.javacc.statement.Block;
import org.shaolin.javacc.statement.BlockCompilationUnit;
import org.shaolin.javacc.statement.BlockStatement;
import org.shaolin.javacc.statement.BreakStatement;
import org.shaolin.javacc.statement.CompilationUnit;
import org.shaolin.javacc.statement.ContinueStatement;
import org.shaolin.javacc.statement.DoStatement;
import org.shaolin.javacc.statement.EmptyStatement;
import org.shaolin.javacc.statement.ExpressionCompilationUnit;
import org.shaolin.javacc.statement.ForStatement;
import org.shaolin.javacc.statement.FormalParameter;
import org.shaolin.javacc.statement.IfStatement;
import org.shaolin.javacc.statement.LabeledStatement;
import org.shaolin.javacc.statement.LocalVariableDeclaration;
import org.shaolin.javacc.statement.ReturnStatement;
import org.shaolin.javacc.statement.Statement;
import org.shaolin.javacc.statement.StatementExpression;
import org.shaolin.javacc.statement.StatementExpressionList;
import org.shaolin.javacc.statement.SwitchStatement;
import org.shaolin.javacc.statement.ThrowStatement;
import org.shaolin.javacc.statement.TryStatement;
import org.shaolin.javacc.statement.WhileStatement;
import org.shaolin.javacc.symbol.AllocationExpression;
import org.shaolin.javacc.symbol.Argument;
import org.shaolin.javacc.symbol.ArgumentList;
import org.shaolin.javacc.symbol.ArrayAccessOperator;
import org.shaolin.javacc.symbol.ArrayDimsAndInits;
import org.shaolin.javacc.symbol.ArrayExpression;
import org.shaolin.javacc.symbol.ArrayInitExpression;
import org.shaolin.javacc.symbol.AssignmentOperator;
import org.shaolin.javacc.symbol.BitOperator;
import org.shaolin.javacc.symbol.CastExpression;
import org.shaolin.javacc.symbol.ClassExpression;
import org.shaolin.javacc.symbol.ConditionalOperator;
import org.shaolin.javacc.symbol.EqualityOperator;
import org.shaolin.javacc.symbol.ExpressionNode;
import org.shaolin.javacc.symbol.FieldExpression;
import org.shaolin.javacc.symbol.FieldName;
import org.shaolin.javacc.symbol.FunctionExpression;
import org.shaolin.javacc.symbol.IncrDecrOperator;
import org.shaolin.javacc.symbol.InstanceofOperator;
import org.shaolin.javacc.symbol.Literal;
import org.shaolin.javacc.symbol.LogicOperator;
import org.shaolin.javacc.symbol.NumericOperator;
import org.shaolin.javacc.symbol.PrimitiveType;
import org.shaolin.javacc.symbol.RelationalOperator;
import org.shaolin.javacc.symbol.ShiftOperator;
import org.shaolin.javacc.symbol.TypeExpression;
import org.shaolin.javacc.symbol.UnaryOperator;

public class Parser implements ParserConstants {

    Statement currentBlock = null;
    List loopSmt = new ArrayList();
    ExpressionNode returnType = null;
    List importArrayList = new ArrayList();
    boolean hasDefineReturnType = false;

        public static ExpressionNode parseExpression(String expression) throws Exception
        {
        ExpressionNode result = null;
        if(expression != null && expression.trim().length() > 0)
                {
                    Parser parser = new Parser(new StringReader(expression));
                result = parser.parse();
                }
                else
                {
                    throw new ParsingException("Expression can't be null or empty string");
                }
        return result;
        }

        public static CompilationUnit parseStatement(String statement) throws Exception
    {
        CompilationUnit compilationUnit = null;
        if(statement != null && statement.trim().length() > 0)
            {
                 Parser parser = new Parser(new StringReader(statement));
                 compilationUnit = parser.CompilationUnit(statement);
        }
        else
        {
               throw new ParsingException("Expression can't be null or empty string");
        }
         return compilationUnit;
    }

    private ExpressionNode makeAssignExpressionNode(ExpressionNode lChild, ExpressionNode rChild, String op)
    {

        if (op.length() > 1)
        {
            String caculateType = op.substring(0, op.length() - 1 );
            // numeric operator
            if (caculateType.equals("+") || caculateType.equals("-") || caculateType.equals("*") || caculateType.equals("/"))
            {
              return makeNumericOperator(lChild, rChild, caculateType);
            }
            // bit operate
            if (caculateType.equals("|") || caculateType.equals("&") || caculateType.equals("^"))
            {
                return makeBitOperator(lChild, rChild, caculateType);
            }
            // shift operate
            if(caculateType.equals("<<") || caculateType.equals(">>") || caculateType.equals(">>"))
            {
                return makeShiftOperator(lChild, rChild, caculateType);
            }
            // never go to here
            //throw new ParsingException("Can't indentify  " + caculateType + " operater");
        }
        return rChild;
    }


        private ExpressionNode makeLogicOperator(ExpressionNode lChild, ExpressionNode rChild, String op)
        {
                LogicOperator node = new LogicOperator(op);
                node.addChild(lChild);
                node.addChild(rChild);
                return node;
        }

        private ExpressionNode makeBitOperator(ExpressionNode lChild, ExpressionNode rChild, String op)
        {
                BitOperator node = new BitOperator(op);
                node.addChild(lChild);
                node.addChild(rChild);
                return node;
        }

        private ExpressionNode makeShiftOperator(ExpressionNode lChild, ExpressionNode rChild, String op)
        {
                ShiftOperator node = new ShiftOperator(op);
                node.addChild(lChild);
                node.addChild(rChild);
                return node;
        }

        private ExpressionNode makeNumericOperator(ExpressionNode lChild, ExpressionNode rChild, String op)
        {
                NumericOperator node = new NumericOperator(op);
                node.addChild(lChild);
                node.addChild(rChild);
                return node;
        }

        private ExpressionNode makeUnaryOperator(ExpressionNode child, String op)
        {
                UnaryOperator node = new UnaryOperator(op);
                node.addChild(child);
                return node;
        }

        private ExpressionNode makeIncrDecrOperator(ExpressionNode child, String op, boolean isPrefix)
        {
                IncrDecrOperator node = new IncrDecrOperator(op);
                node.setIsPrefix(isPrefix);
                node.addChild(child);
                return node;
        }

        private ExpressionNode makeCastExpression(ExpressionNode typeNode, ExpressionNode exprNode)
        {
                CastExpression node = new CastExpression();
                node.addChild(typeNode);
                node.addChild(exprNode);
                return node;
        }

/**********************************************
 * THE OOEE EXPRESSION GRAMMAR STARTS HERE *
 **********************************************/
  final public CompilationUnit CompilationUnit(String statement) throws ParseException, ParsingException {
    Block block = null;
    ExpressionNode exp = null;
    CompilationUnit compilationUnit = null;
    List importList = null;
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IMPORT:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      ImportDeclaration();
    }
    if (jj_2_1(2147483647)) {
      block = MainBlock();
      jj_consume_token(0);
     compilationUnit = new BlockCompilationUnit(statement, block, returnType, importArrayList);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PRIMITIVETYPE:
      case PLUSMINUS:
      case INCRDECR:
      case NEW:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case STRING_LITERAL:
      case CHARACTER_LITERAL:
      case BOOLEAN_LITERAL:
      case NULL_LITERAL:
      case IDENTIFIER:
      case 111:
      case 130:
      case 131:
        exp = Expression();
        label_2:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 108:
            ;
            break;
          default:
            jj_la1[1] = jj_gen;
            break label_2;
          }
          jj_consume_token(108);
        }
        jj_consume_token(0);
      compilationUnit = new ExpressionCompilationUnit(statement, exp, importArrayList);
        break;
      default:
        jj_la1[2] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
      {if (true) return compilationUnit;}
    throw new Error("Missing return statement in function");
  }

  final public Block MainBlock() throws ParseException, ParsingException {
    Block block = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PRIMITIVETYPE:
    case VOID:
    case IDENTIFIER:
      Declare();
           hasDefineReturnType = true;
      break;
    default:
      jj_la1[3] = jj_gen;
      ;
    }
    block = Block();
        {if (true) return block;}
    throw new Error("Missing return statement in function");
  }

  final public void Declare() throws ParseException, ParsingException {
   ExpressionNode node;
    returnType = ResultType();
  }

  final public Statement Statement() throws ParseException, ParsingException {
    Statement smt = null;
    if (jj_2_2(2)) {
      smt = LabeledStatement();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASSERT:
        smt = AssertStatement();
        break;
      case 107:
        smt = Block();
        break;
      case 108:
        smt = EmptyStatement();
        break;
      case PRIMITIVETYPE:
      case INCRDECR:
      case NEW:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case STRING_LITERAL:
      case CHARACTER_LITERAL:
      case BOOLEAN_LITERAL:
      case NULL_LITERAL:
      case IDENTIFIER:
      case 111:
        smt = StatementExpression();
        jj_consume_token(108);
        break;
      case IF:
        smt = IfStatement();
        break;
      case WHILE:
        smt = WhileStatement();
        break;
      case DO:
        smt = DoStatement();
        break;
      case FOR:
        smt = ForStatement();
        break;
      case BREAK:
        smt = BreakStatement();
        break;
      case CONTINUE:
        smt = ContinueStatement();
        break;
      case RETURN:
        smt = ReturnStatement();
        break;
      case SWITCH:
        smt = SwitchStatement();
        break;
      case THROW:
        smt = ThrowStatement();
        break;
      case TRY:
        smt = TryStatement();
        break;
      default:
        jj_la1[4] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
        {if (true) return smt;}
    throw new Error("Missing return statement in function");
  }

  final public void ImportDeclaration() throws ParseException {
    String importName = null;
    jj_consume_token(IMPORT);
    importName = ImportName();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 109:
      jj_consume_token(109);
      jj_consume_token(MULDIV);
      importName = importName + ".*";
      importArrayList.add(importName);
      break;
    default:
      jj_la1[5] = jj_gen;
      ;
    }
 importArrayList.add(importName);
    jj_consume_token(108);
  }

  final public String ImportName() throws ParseException {
    String importName = null;
    Token temp =null;
    Token t;
    t = jj_consume_token(IDENTIFIER);
      importName = t.image;
    label_3:
    while (true) {
      if (jj_2_3(2)) {
        ;
      } else {
        break label_3;
      }
      jj_consume_token(109);
      temp = jj_consume_token(IDENTIFIER);
      importName = importName + "." + temp.image;
    }
      {if (true) return importName;}
    throw new Error("Missing return statement in function");
  }

  final public AssertStatement AssertStatement() throws ParseException, ParsingException {
    ExpressionNode assertExpNode = null, valueExpNode = null;
    AssertStatement assertStatement = new AssertStatement();
    jj_consume_token(ASSERT);
    assertExpNode = Expression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 110:
      jj_consume_token(110);
      valueExpNode = Expression();
      break;
    default:
      jj_la1[6] = jj_gen;
      ;
    }
    jj_consume_token(108);
      assertExpNode.setParentBlock(currentBlock);
      assertStatement.setAssertExp(assertExpNode);
      if(valueExpNode != null)
      {
          valueExpNode.setParentBlock(currentBlock);
          assertStatement.setValuetExp(valueExpNode);
      }
      assertStatement.setParentBlock(currentBlock);
      {if (true) return assertStatement;}
    throw new Error("Missing return statement in function");
  }

  final public LabeledStatement LabeledStatement() throws ParseException, ParsingException {
    LabeledStatement labeledStatement = new LabeledStatement();
    Statement labeledSmt;
    jj_consume_token(IDENTIFIER);
    jj_consume_token(110);
    labeledSmt = Statement();
      labeledStatement.setLabeledStatement(labeledSmt);
      labeledStatement.setParentBlock(currentBlock);
      {if (true) return labeledStatement;}
    throw new Error("Missing return statement in function");
  }

  final public EmptyStatement EmptyStatement() throws ParseException, ParsingException {
    EmptyStatement emptySmt = new EmptyStatement();
    jj_consume_token(108);
      emptySmt.setParentBlock(currentBlock);
      {if (true) return emptySmt;}
    throw new Error("Missing return statement in function");
  }

  final public StatementExpression StatementExpression() throws ParseException, ParsingException {
    ExpressionNode preIncrDecrExp,primaryExp,assignExp,newNode;
    StatementExpression SmtExp = new StatementExpression();
    Token t;
    String op,assignOper;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INCRDECR:
      preIncrDecrExp = PreIncrDecrExpression();
      preIncrDecrExp.setParentBlock(currentBlock);
      SmtExp.setStatementExp(preIncrDecrExp);
      {if (true) return SmtExp;}
      break;
    case PRIMITIVETYPE:
    case NEW:
    case VOID:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case CHARACTER_LITERAL:
    case BOOLEAN_LITERAL:
    case NULL_LITERAL:
    case IDENTIFIER:
    case 111:
      primaryExp = PrimaryExpression();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INCRDECR:
      case ASSIGN:
      case 117:
      case 118:
      case 119:
      case 120:
      case 121:
      case 122:
      case 123:
      case 124:
      case 125:
      case 126:
      case 127:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INCRDECR:
          t = jj_consume_token(INCRDECR);
      op = t.image;
      primaryExp=makeIncrDecrOperator(primaryExp,op,false);
          break;
        case ASSIGN:
        case 117:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
        case 123:
        case 124:
        case 125:
        case 126:
        case 127:
          assignOper = AssignmentOperator();
          assignExp = Expression();
      // alway set "=" operater
      newNode = new AssignmentOperator("=");
      newNode.addChild(primaryExp);
      // separete "a += b" to "a = a + b"
      newNode.addChild(makeAssignExpressionNode(primaryExp, assignExp, assignOper));
      primaryExp = newNode;
          break;
        default:
          jj_la1[7] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[8] = jj_gen;
        ;
      }
      primaryExp.setParentBlock(currentBlock);
      SmtExp.setStatementExp(primaryExp);
      SmtExp.setParentBlock(currentBlock);
      {if (true) return SmtExp;}
      break;
    default:
      jj_la1[9] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public SwitchStatement SwitchStatement() throws ParseException, ParsingException {
    ExpressionNode switchExpNode, switchLabelExp = null;
    SwitchStatement switchStatement = new SwitchStatement();
    Object switchLabel;
    List blockSmtList = new ArrayList();
    BlockStatement blockSmt = new BlockStatement();
    String defaultCase = null;
    switchStatement.setParentBlock(currentBlock);
    currentBlock = switchStatement;
    loopSmt.add(switchStatement);
    jj_consume_token(SWITCH);
    jj_consume_token(111);
    switchExpNode = Expression();
      switchExpNode.setParentBlock(currentBlock);
      switchStatement.setSwitchExpression(switchExpNode);
    jj_consume_token(112);
    jj_consume_token(107);
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CASE:
      case _DEFAULT:
        ;
        break;
      default:
        jj_la1[10] = jj_gen;
        break label_4;
      }
      switchLabel = SwitchLabel();
      if(switchLabel instanceof String)
      {
          String name = (String)switchLabel;
          if(name.equals("default"))
              defaultCase = "default";
      }
      else
      {
          switchLabelExp = (ExpressionNode)switchLabel;
          switchLabelExp.setParentBlock(currentBlock);
          defaultCase = null;
      }
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PRIMITIVETYPE:
        case INCRDECR:
        case NEW:
        case VOID:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case STRING_LITERAL:
        case CHARACTER_LITERAL:
        case BOOLEAN_LITERAL:
        case NULL_LITERAL:
        case ASSERT:
        case BREAK:
        case CONTINUE:
        case DO:
        case FOR:
        case IF:
        case RETURN:
        case SWITCH:
        case THROW:
        case TRY:
        case WHILE:
        case IDENTIFIER:
        case 107:
        case 108:
        case 111:
          ;
          break;
        default:
          jj_la1[11] = jj_gen;
          break label_5;
        }
        blockSmt = BlockStatement();
      blockSmt.setParentBlock(currentBlock);
      blockSmtList.add(blockSmt);
      }
      if(defaultCase != null)
      {
          switchStatement.getSwitchCase().put("default",blockSmtList);
          switchStatement.getCaseList().add("default");
          switchStatement.getCaseValueList().add(blockSmtList);
      }
      else
      {
          switchStatement.getSwitchCase().put(switchLabelExp,blockSmtList);
          switchStatement.getCaseList().add(switchLabelExp);
          switchStatement.getCaseValueList().add(blockSmtList);
      }
      blockSmtList = new ArrayList();
    }
    jj_consume_token(113);
      currentBlock = switchStatement.getParentBlock();
      loopSmt.remove(loopSmt.size() - 1);
      {if (true) return switchStatement;}
    throw new Error("Missing return statement in function");
  }

  final public Object SwitchLabel() throws ParseException, ParsingException {
    ExpressionNode switchExpNode;
    String defaultCase = "default";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CASE:
      jj_consume_token(CASE);
      switchExpNode = Expression();
      jj_consume_token(110);
       switchExpNode.setParentBlock(currentBlock);
       {if (true) return switchExpNode;}
      break;
    case _DEFAULT:
      jj_consume_token(_DEFAULT);
      jj_consume_token(110);
       {if (true) return defaultCase;}
      break;
    default:
      jj_la1[12] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public IfStatement IfStatement() throws ParseException, ParsingException {
    IfStatement ifStatement = new IfStatement();
    Statement ifSmt;
    Statement elseSmt = null;
    ExpressionNode ifExpNode;
    jj_consume_token(IF);
    jj_consume_token(111);
    ifExpNode = Expression();
    jj_consume_token(112);
    ifSmt = Statement();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ELSE:
      jj_consume_token(ELSE);
      elseSmt = Statement();
      break;
    default:
      jj_la1[13] = jj_gen;
      ;
    }
     //  ifExp = new Expression(ifExpNode.toString());
       ifExpNode.setParentBlock(currentBlock);
       ifStatement.setParentBlock(currentBlock);
       ifStatement.setIfExpression(ifExpNode);
       ifStatement.setIfStatement(ifSmt);
       ifStatement.setElseStatement(elseSmt);
       {if (true) return ifStatement;}
    throw new Error("Missing return statement in function");
  }

  final public WhileStatement WhileStatement() throws ParseException, ParsingException {
    WhileStatement whileStatement = new WhileStatement();
    ExpressionNode whileExpNode;
    Statement whileSmt;
    loopSmt.add(whileStatement);
    jj_consume_token(WHILE);
    jj_consume_token(111);
    whileExpNode = Expression();
    jj_consume_token(112);
    whileSmt = Statement();
   //   whileExp = new Expression(whileExpNode.toString());
      whileExpNode.setParentBlock(currentBlock);
      whileStatement.setWhileExpression(whileExpNode);
      whileStatement.setWhileStatement(whileSmt);
      whileStatement.setParentBlock(currentBlock);
      loopSmt.remove(loopSmt.size() - 1);
      {if (true) return whileStatement;}
    throw new Error("Missing return statement in function");
  }

  final public DoStatement DoStatement() throws ParseException, ParsingException {
    DoStatement doStatement = new DoStatement();
    ExpressionNode doExpNode;
    Statement doSmt;
    loopSmt.add(doStatement);
    jj_consume_token(DO);
    doSmt = Statement();
    jj_consume_token(WHILE);
    jj_consume_token(111);
    doExpNode = Expression();
    jj_consume_token(112);
    jj_consume_token(108);
   //   doExp = new Expression(doExpNode.toString());
      doExpNode.setParentBlock(currentBlock);
      doStatement.setDoExpression(doExpNode);
      doStatement.setDoStatement(doSmt);
      doStatement.setParentBlock(currentBlock);
      loopSmt.remove(loopSmt.size() - 1);
      {if (true) return doStatement;}
    throw new Error("Missing return statement in function");
  }

  final public ForStatement ForStatement() throws ParseException, ParsingException {
    Object forInit = null;
    ForStatement forStatement = new ForStatement();
    forStatement.setParentBlock(currentBlock);
    currentBlock = forStatement;
    Statement forSmt = null;
    ExpressionNode forExpNode = null;
    StatementExpressionList updateSmtList = new StatementExpressionList();
    loopSmt.add(forStatement);
    jj_consume_token(FOR);
    jj_consume_token(111);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PRIMITIVETYPE:
    case INCRDECR:
    case NEW:
    case VOID:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case CHARACTER_LITERAL:
    case BOOLEAN_LITERAL:
    case NULL_LITERAL:
    case IDENTIFIER:
    case 111:
      forInit = ForInit();
         if(forInit instanceof LocalVariableDeclaration )
         {
             forStatement.setInitVarDec((LocalVariableDeclaration)forInit);
         }
         else
         {
             forStatement.setInitSmtList((StatementExpressionList)forInit);
         }
      break;
    default:
      jj_la1[14] = jj_gen;
      ;
    }
    jj_consume_token(108);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PRIMITIVETYPE:
    case PLUSMINUS:
    case INCRDECR:
    case NEW:
    case VOID:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case CHARACTER_LITERAL:
    case BOOLEAN_LITERAL:
    case NULL_LITERAL:
    case IDENTIFIER:
    case 111:
    case 130:
    case 131:
      forExpNode = Expression();
       //  forExp = new Expression(forExpNode.toString());
         forExpNode.setParentBlock(currentBlock);
         forStatement.setForExp(forExpNode);
      break;
    default:
      jj_la1[15] = jj_gen;
      ;
    }
    jj_consume_token(108);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PRIMITIVETYPE:
    case INCRDECR:
    case NEW:
    case VOID:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case CHARACTER_LITERAL:
    case BOOLEAN_LITERAL:
    case NULL_LITERAL:
    case IDENTIFIER:
    case 111:
      updateSmtList = ForUpdate();
         forStatement.setUpdateSmtList(updateSmtList);
      break;
    default:
      jj_la1[16] = jj_gen;
      ;
    }
    jj_consume_token(112);
    forSmt = Statement();
      forStatement.setForSmt(forSmt);
      currentBlock = forStatement.getParentBlock();
      loopSmt.remove(loopSmt.size() - 1);
      {if (true) return forStatement;}
    throw new Error("Missing return statement in function");
  }

  final public Object ForInit() throws ParseException, ParsingException {
    Object forInit = null;
    if (jj_2_4(2147483647)) {
      forInit = LocalVariableDeclaration();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PRIMITIVETYPE:
      case INCRDECR:
      case NEW:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case STRING_LITERAL:
      case CHARACTER_LITERAL:
      case BOOLEAN_LITERAL:
      case NULL_LITERAL:
      case IDENTIFIER:
      case 111:
        forInit = StatementExpressionList();
        break;
      default:
        jj_la1[17] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
      {if (true) return forInit;}
    throw new Error("Missing return statement in function");
  }

  final public StatementExpressionList StatementExpressionList() throws ParseException, ParsingException {
    StatementExpressionList smtExpList = new StatementExpressionList();
    smtExpList.setParentBlock(currentBlock);
    StatementExpression smtExp;
    smtExp = StatementExpression();
      smtExp.setParentBlock(currentBlock);
      smtExpList.getSmtExpList().add(smtExp);
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 114:
        ;
        break;
      default:
        jj_la1[18] = jj_gen;
        break label_6;
      }
      jj_consume_token(114);
      smtExp = StatementExpression();
      smtExp.setParentBlock(currentBlock);
      smtExpList.getSmtExpList().add(smtExp);
    }
      {if (true) return smtExpList;}
    throw new Error("Missing return statement in function");
  }

  final public StatementExpressionList ForUpdate() throws ParseException, ParsingException {
    StatementExpressionList updateSmtList = new StatementExpressionList();
    updateSmtList = StatementExpressionList();
      {if (true) return updateSmtList;}
    throw new Error("Missing return statement in function");
  }

  final public BreakStatement BreakStatement() throws ParseException, ParsingException {
    Token t;
    BreakStatement breakSmt = new BreakStatement();
    jj_consume_token(BREAK);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      t = jj_consume_token(IDENTIFIER);
      breakSmt.setBreakID(t.image);
      break;
    default:
      jj_la1[19] = jj_gen;
      ;
    }
    jj_consume_token(108);
      breakSmt.setParentBlock(currentBlock);
      if(loopSmt.size() > 0)
      {
      breakSmt.setParentSmt((Statement)loopSmt.get(loopSmt.size() - 1));
      {if (true) return breakSmt;}
      }
      else {if (true) throw new ParsingException("break cannot be used outside of a loop or a switch");}
    throw new Error("Missing return statement in function");
  }

  final public ContinueStatement ContinueStatement() throws ParseException, ParsingException {
    Token t;
    ContinueStatement continueSmt = new ContinueStatement();
    jj_consume_token(CONTINUE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      t = jj_consume_token(IDENTIFIER);
      continueSmt.setContinueID(t.image);
      break;
    default:
      jj_la1[20] = jj_gen;
      ;
    }
    jj_consume_token(108);
      continueSmt.setParentBlock(currentBlock);
      if(loopSmt.size() > 0)
      {
        int i = loopSmt.size() - 1;
        while(i>=0)
        {
            Object smt = loopSmt.get(i);
            if(!(smt instanceof SwitchStatement))
            {
                continueSmt.setParentSmt((Statement)loopSmt.get(loopSmt.size() - 1));
                {if (true) return continueSmt;}
            }
            i--;
        }
        {if (true) throw new ParsingException("continue cannot be used outside of a loop");}
      }
      else {if (true) throw new ParsingException("continue cannot be used outside of a loop");}
    throw new Error("Missing return statement in function");
  }

  final public ReturnStatement ReturnStatement() throws ParseException, ParsingException {
    ReturnStatement returnSmt = new ReturnStatement();
    ExpressionNode returnNode = null;
    jj_consume_token(RETURN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PRIMITIVETYPE:
    case PLUSMINUS:
    case INCRDECR:
    case NEW:
    case VOID:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case CHARACTER_LITERAL:
    case BOOLEAN_LITERAL:
    case NULL_LITERAL:
    case IDENTIFIER:
    case 111:
    case 130:
    case 131:
      returnNode = Expression();
      returnNode.setParentBlock(currentBlock);
      returnSmt.setReturnExp(returnNode);
      break;
    default:
      jj_la1[21] = jj_gen;
      ;
    }
    jj_consume_token(108);
      returnSmt.setParentBlock(currentBlock);
      returnSmt.setHasDefineReturnType(hasDefineReturnType);
      returnSmt.setDeclareReturnType(returnType);
      {if (true) return returnSmt;}
    throw new Error("Missing return statement in function");
  }

  final public ThrowStatement ThrowStatement() throws ParseException, ParsingException {
    ExpressionNode throwExpNode;
    ThrowStatement throwSmt = new ThrowStatement();
    jj_consume_token(THROW);
    throwExpNode = Expression();
    jj_consume_token(108);
      throwExpNode.setParentBlock(currentBlock);
      throwSmt.setThrowExp(throwExpNode);
      throwSmt.setParentBlock(currentBlock);
      {if (true) return throwSmt;}
    throw new Error("Missing return statement in function");
  }

  final public TryStatement TryStatement() throws ParseException, ParsingException {
    TryStatement trySmt = new TryStatement();
    Block tryBlock,finalBlock,tempBlock = new Block();
    FormalParameter formalPara = new FormalParameter();
    jj_consume_token(TRY);
    tryBlock = Block();
      trySmt.setTryBlock(tryBlock);
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CATCH:
        ;
        break;
      default:
        jj_la1[22] = jj_gen;
        break label_7;
      }
      jj_consume_token(CATCH);
      jj_consume_token(111);
      formalPara = FormalParameter();
      jj_consume_token(112);
      tempBlock = Block();
      trySmt.getCatchBlock().put(formalPara,tempBlock);
      trySmt.getCatchValueList().add(formalPara);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FINALLY:
      jj_consume_token(FINALLY);
      finalBlock = Block();
      trySmt.setFinalBlock(finalBlock);
      break;
    default:
      jj_la1[23] = jj_gen;
      ;
    }
      trySmt.setParentBlock(currentBlock);
      {if (true) return trySmt;}
    throw new Error("Missing return statement in function");
  }

  final public Block Block() throws ParseException, ParsingException {
    Block block = new Block();
    block.setParentBlock(currentBlock);
    currentBlock = block;
    BlockStatement blockSmt = new BlockStatement();
    jj_consume_token(107);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PRIMITIVETYPE:
      case INCRDECR:
      case NEW:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case STRING_LITERAL:
      case CHARACTER_LITERAL:
      case BOOLEAN_LITERAL:
      case NULL_LITERAL:
      case ASSERT:
      case BREAK:
      case CONTINUE:
      case DO:
      case FOR:
      case IF:
      case RETURN:
      case SWITCH:
      case THROW:
      case TRY:
      case WHILE:
      case IDENTIFIER:
      case 107:
      case 108:
      case 111:
        ;
        break;
      default:
        jj_la1[24] = jj_gen;
        break label_8;
      }
      blockSmt = BlockStatement();
             block.getBlockSmtList().add(blockSmt);
    }
    jj_consume_token(113);
        currentBlock = block.getParentBlock();
        {if (true) return block;}
    throw new Error("Missing return statement in function");
  }

  final public BlockStatement BlockStatement() throws ParseException, ParsingException {
    BlockStatement blockSmt = new BlockStatement();
    LocalVariableDeclaration localVarDec = null;
    Statement blockSmtElement = null;
    if (jj_2_5(2147483647)) {
      localVarDec = LocalVariableDeclaration();
      jj_consume_token(108);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PRIMITIVETYPE:
      case INCRDECR:
      case NEW:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case STRING_LITERAL:
      case CHARACTER_LITERAL:
      case BOOLEAN_LITERAL:
      case NULL_LITERAL:
      case ASSERT:
      case BREAK:
      case CONTINUE:
      case DO:
      case FOR:
      case IF:
      case RETURN:
      case SWITCH:
      case THROW:
      case TRY:
      case WHILE:
      case IDENTIFIER:
      case 107:
      case 108:
      case 111:
        blockSmtElement = Statement();
        break;
      default:
        jj_la1[25] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
      if(localVarDec == null)
          blockSmt.setBlockSmt(blockSmtElement);
      else
          blockSmt.setLocalVar(localVarDec);
      blockSmt.setParentBlock(currentBlock);
      {if (true) return blockSmt;}
    throw new Error("Missing return statement in function");
  }

  final public LocalVariableDeclaration LocalVariableDeclaration() throws ParseException, ParsingException {
    LocalVariableDeclaration localVarDec = new LocalVariableDeclaration();
    ExpressionNode typeNode = null;
    typeNode = Type();
    VariableDeclarator(localVarDec.getValueMap(),localVarDec.getVarName());
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 114:
        ;
        break;
      default:
        jj_la1[26] = jj_gen;
        break label_9;
      }
      jj_consume_token(114);
      VariableDeclarator(localVarDec.getValueMap(),localVarDec.getVarName());
    }
      localVarDec.setTypeNode(typeNode);
      localVarDec.setParentBlock(currentBlock);
      {if (true) return localVarDec;}
    throw new Error("Missing return statement in function");
  }

  final public void VariableDeclarator(Map map,List list) throws ParseException {
    String name = null;
    ExpressionNode varNode = null;
    name = VariableDeclaratorId();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASSIGN:
      jj_consume_token(ASSIGN);
      varNode = VariableInitializer();
      break;
    default:
      jj_la1[27] = jj_gen;
      ;
    }
      if(varNode != null)
          varNode.setParentBlock(currentBlock);
      map.put(name,varNode);
      list.add(name);
  }

  final public String VariableDeclaratorId() throws ParseException {
    Token t;
    t = jj_consume_token(IDENTIFIER);
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 115:
        ;
        break;
      default:
        jj_la1[28] = jj_gen;
        break label_10;
      }
      jj_consume_token(115);
      jj_consume_token(116);
    }
      {if (true) return t.image;}
    throw new Error("Missing return statement in function");
  }

  final public String AssignmentOperator() throws ParseException {
  String assignOper;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASSIGN:
      assignOper = jj_consume_token(ASSIGN).image;
      break;
    case 117:
      assignOper = jj_consume_token(117).image;
      break;
    case 118:
      assignOper = jj_consume_token(118).image;
      break;
    case 119:
      assignOper = jj_consume_token(119).image;
      break;
    case 120:
      assignOper = jj_consume_token(120).image;
      break;
    case 121:
      assignOper = jj_consume_token(121).image;
      break;
    case 122:
      assignOper = jj_consume_token(122).image;
      break;
    case 123:
      assignOper = jj_consume_token(123).image;
      break;
    case 124:
      assignOper = jj_consume_token(124).image;
      break;
    case 125:
      assignOper = jj_consume_token(125).image;
      break;
    case 126:
      assignOper = jj_consume_token(126).image;
      break;
    case 127:
      assignOper = jj_consume_token(127).image;
      break;
    default:
      jj_la1[29] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return assignOper;}
    throw new Error("Missing return statement in function");
  }

  final public void FormalParameters() throws ParseException, ParsingException {
    jj_consume_token(111);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PRIMITIVETYPE:
    case IDENTIFIER:
      FormalParameter();
      label_11:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 114:
          ;
          break;
        default:
          jj_la1[30] = jj_gen;
          break label_11;
        }
        jj_consume_token(114);
        FormalParameter();
      }
      break;
    default:
      jj_la1[31] = jj_gen;
      ;
    }
    jj_consume_token(112);
  }

  final public FormalParameter FormalParameter() throws ParseException, ParsingException {
  ExpressionNode type;
  String parameterID;
  FormalParameter formalParameter = new FormalParameter();
  formalParameter.setParentBlock(currentBlock);
    type = Type();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 128:
      jj_consume_token(128);
      break;
    default:
      jj_la1[32] = jj_gen;
      ;
    }
    parameterID = VariableDeclaratorId();
      formalParameter.setType(type);
      formalParameter.setParameterID(parameterID);
      {if (true) return formalParameter;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionNode parse() throws ParseException, ParsingException {
        ExpressionNode root;
    root = Expression();
    jj_consume_token(0);
                {if (true) return root;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionNode Expression() throws ParseException {
        ExpressionNode node, tmpNode, newNode;
        String assignOper;
    node = ConditionalExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASSIGN:
    case 117:
    case 118:
    case 119:
    case 120:
    case 121:
    case 122:
    case 123:
    case 124:
    case 125:
    case 126:
    case 127:
      assignOper = AssignmentOperator();
      tmpNode = Expression();
            newNode = new AssignmentOperator("=");
            newNode.addChild(node);
            // separete "a += b" to "a = a + b"
            newNode.addChild(makeAssignExpressionNode(node, tmpNode, assignOper));
            node = newNode;
      break;
    default:
      jj_la1[33] = jj_gen;
      ;
    }
        {if (true) return node;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionNode ConditionalExpression() throws ParseException {
    ExpressionNode node, trueNode, falseNode, tmpNode;
    node = ConditionalOrExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 129:
      jj_consume_token(129);
      trueNode = Expression();
      jj_consume_token(110);
      falseNode = ConditionalExpression();
        tmpNode = new ConditionalOperator();
        tmpNode.addChild(node);
        tmpNode.addChild(trueNode);
        tmpNode.addChild(falseNode);
        node = tmpNode;
      break;
    default:
      jj_la1[34] = jj_gen;
      ;
    }
        {if (true) return node;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionNode ConditionalOrExpression() throws ParseException {
    ExpressionNode node, tmpNode;
    Token t;
    String op;
    node = ConditionalAndExpression();
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OR:
        ;
        break;
      default:
        jj_la1[35] = jj_gen;
        break label_12;
      }
      t = jj_consume_token(OR);
            op = t.image;
      tmpNode = ConditionalAndExpression();
                        node = makeLogicOperator(node, tmpNode, op);
    }
        {if (true) return node;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionNode ConditionalAndExpression() throws ParseException {
    ExpressionNode node, tmpNode;
    Token t;
    String op;
    node = InclusiveOrExpression();
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        ;
        break;
      default:
        jj_la1[36] = jj_gen;
        break label_13;
      }
      t = jj_consume_token(AND);
            op = t.image;
      tmpNode = InclusiveOrExpression();
                        node = makeLogicOperator(node, tmpNode, op);
    }
        {if (true) return node;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionNode InclusiveOrExpression() throws ParseException {
    ExpressionNode node, tmpNode;
    Token t;
    String op;
    node = ExclusiveOrExpression();
    label_14:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIT_OR:
        ;
        break;
      default:
        jj_la1[37] = jj_gen;
        break label_14;
      }
      t = jj_consume_token(BIT_OR);
            op = t.image;
      tmpNode = ExclusiveOrExpression();
            node = makeBitOperator(node, tmpNode, op);
    }
        {if (true) return node;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionNode ExclusiveOrExpression() throws ParseException {
    ExpressionNode node, tmpNode;
    Token t;
    String op;
    node = BitAndExpression();
    label_15:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case XOR:
        ;
        break;
      default:
        jj_la1[38] = jj_gen;
        break label_15;
      }
      t = jj_consume_token(XOR);
            op = t.image;
      tmpNode = BitAndExpression();
            node = makeBitOperator(node, tmpNode, op);
    }
        {if (true) return node;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionNode BitAndExpression() throws ParseException {
    ExpressionNode node, tmpNode;
    Token t;
    String op;
    node = EqualityExpression();
    label_16:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIT_AND:
        ;
        break;
      default:
        jj_la1[39] = jj_gen;
        break label_16;
      }
      t = jj_consume_token(BIT_AND);
            op = t.image;
      tmpNode = EqualityExpression();
            node = makeBitOperator(node, tmpNode, op);
    }
        {if (true) return node;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionNode EqualityExpression() throws ParseException {
    ExpressionNode node, tmpNode, newNode;
    Token t;
    String op;
    node = InstanceOfExpression();
    label_17:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUALOP:
        ;
        break;
      default:
        jj_la1[40] = jj_gen;
        break label_17;
      }
      t = jj_consume_token(EQUALOP);
            op = t.image;
      tmpNode = InstanceOfExpression();
            newNode = new EqualityOperator(op);
            newNode.addChild(node);
            newNode.addChild(tmpNode);
            node = newNode;
    }
        {if (true) return node;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionNode InstanceOfExpression() throws ParseException {
    ExpressionNode node, tmpNode;
    node = RelationalExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INSTANCEOF:
      jj_consume_token(INSTANCEOF);
      tmpNode = Type();
            InstanceofOperator newNode = new InstanceofOperator();
            newNode.addChild(node);
            newNode.addChild(tmpNode);
            node = newNode;
      break;
    default:
      jj_la1[41] = jj_gen;
      ;
    }
        {if (true) return node;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionNode RelationalExpression() throws ParseException {
    ExpressionNode node, tmpNode, newNode;
    Token t;
    String op;
    node = ShiftExpression();
    label_18:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case RELATIONOP:
        ;
        break;
      default:
        jj_la1[42] = jj_gen;
        break label_18;
      }
      t = jj_consume_token(RELATIONOP);
            op = t.image;
      tmpNode = ShiftExpression();
            newNode = new RelationalOperator(op);
            newNode.addChild(node);
            newNode.addChild(tmpNode);
            node = newNode;
    }
        {if (true) return node;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionNode ShiftExpression() throws ParseException {
    ExpressionNode node, tmpNode;
    Token t;
    String op;
    node = AdditiveExpression();
    label_19:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SHIFTOP:
        ;
        break;
      default:
        jj_la1[43] = jj_gen;
        break label_19;
      }
      t = jj_consume_token(SHIFTOP);
            op = t.image;
      tmpNode = AdditiveExpression();
            node = makeShiftOperator(node, tmpNode, op);
    }
        {if (true) return node;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionNode AdditiveExpression() throws ParseException {
    ExpressionNode node, tmpNode;
    Token t;
    String op;
    node = MultiplicativeExpression();
    label_20:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUSMINUS:
        ;
        break;
      default:
        jj_la1[44] = jj_gen;
        break label_20;
      }
      t = jj_consume_token(PLUSMINUS);
            op = t.image;
      tmpNode = MultiplicativeExpression();
            node = makeNumericOperator(node, tmpNode, op);
    }
        {if (true) return node;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionNode MultiplicativeExpression() throws ParseException {
    ExpressionNode node, tmpNode;
    Token t;
    String op;
    node = UnaryExpression();
    label_21:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MULDIV:
        ;
        break;
      default:
        jj_la1[45] = jj_gen;
        break label_21;
      }
      t = jj_consume_token(MULDIV);
            op = t.image;
      tmpNode = UnaryExpression();
            node = makeNumericOperator(node, tmpNode, op);
    }
        {if (true) return node;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionNode UnaryExpression() throws ParseException {
    ExpressionNode node;
    Token t;
    String op;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUSMINUS:
      t = jj_consume_token(PLUSMINUS);
            op = t.image;
      node = UnaryExpression();
            node = makeUnaryOperator(node, op);
      break;
    case INCRDECR:
      node = PreIncrDecrExpression();
      break;
    case PRIMITIVETYPE:
    case NEW:
    case VOID:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case CHARACTER_LITERAL:
    case BOOLEAN_LITERAL:
    case NULL_LITERAL:
    case IDENTIFIER:
    case 111:
    case 130:
    case 131:
      node = UnaryExpressionNotPlusMinus();
      break;
    default:
      jj_la1[46] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return node;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionNode PreIncrDecrExpression() throws ParseException {
    ExpressionNode node;
    Token t;
    String op;
    t = jj_consume_token(INCRDECR);
        op = t.image;
    node = PrimaryExpression();
        node = makeIncrDecrOperator(node, op, true);
        {if (true) return node;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionNode UnaryExpressionNotPlusMinus() throws ParseException {
    ExpressionNode node;
    Token t;
    String op;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 130:
    case 131:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 130:
        t = jj_consume_token(130);
        break;
      case 131:
        t = jj_consume_token(131);
        break;
      default:
        jj_la1[47] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
            op = t.image;
      node = UnaryExpression();
            node = makeUnaryOperator(node, op);
      break;
    default:
      jj_la1[48] = jj_gen;
      if (jj_2_6(2147483647)) {
        node = CastExpression();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PRIMITIVETYPE:
        case NEW:
        case VOID:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case STRING_LITERAL:
        case CHARACTER_LITERAL:
        case BOOLEAN_LITERAL:
        case NULL_LITERAL:
        case IDENTIFIER:
        case 111:
          node = PostIncrDecrExpression();
          break;
        default:
          jj_la1[49] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
        {if (true) return node;}
    throw new Error("Missing return statement in function");
  }

// This production is to determine lookahead only.  The LOOKAHEAD specifications
// below are not used, but they are there just to indicate that we know about
// this.
  final public void CastLookahead() throws ParseException {
    if (jj_2_7(2)) {
      jj_consume_token(111);
      PrimitiveType();
    } else if (jj_2_8(2147483647)) {
      jj_consume_token(111);
      Name();
      jj_consume_token(115);
      jj_consume_token(116);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 111:
        jj_consume_token(111);
        Name();
        jj_consume_token(112);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 130:
          jj_consume_token(130);
          break;
        case 131:
          jj_consume_token(131);
          break;
        case 111:
          jj_consume_token(111);
          break;
        case IDENTIFIER:
          jj_consume_token(IDENTIFIER);
          break;
        case NEW:
          jj_consume_token(NEW);
          break;
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case STRING_LITERAL:
        case CHARACTER_LITERAL:
        case BOOLEAN_LITERAL:
        case NULL_LITERAL:
          Literal();
          break;
        default:
          jj_la1[50] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[51] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public ExpressionNode CastExpression() throws ParseException {
    ExpressionNode node, typeNode;
    if (jj_2_9(2147483647)) {
      jj_consume_token(111);
      typeNode = Type();
      jj_consume_token(112);
      node = UnaryExpression();
        node = makeCastExpression(typeNode, node);
        {if (true) return node;}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 111:
        jj_consume_token(111);
        typeNode = Type();
        jj_consume_token(112);
        node = UnaryExpressionNotPlusMinus();
        node = makeCastExpression(typeNode, node);
        {if (true) return node;}
        break;
      default:
        jj_la1[52] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public ExpressionNode PostIncrDecrExpression() throws ParseException {
    ExpressionNode node;
    Token t;
    String op;
    node = PrimaryExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INCRDECR:
      t = jj_consume_token(INCRDECR);
            op = t.image;
            node = makeIncrDecrOperator(node, op, false);
      break;
    default:
      jj_la1[53] = jj_gen;
      ;
    }
        {if (true) return node;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionNode PrimaryExpression() throws ParseException {
    ExpressionNode node, suffixNode;
    node = PrimaryPrefix();
    label_22:
    while (true) {
      if (jj_2_10(2)) {
        ;
      } else {
        break label_22;
      }
      suffixNode = PrimarySuffix();
            suffixNode.addChild(0, node);
            node = suffixNode;
    }
        {if (true) return node;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionNode PrimaryPrefix() throws ParseException {
    ExpressionNode node, argNode;
    FieldExpression nameNode;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case CHARACTER_LITERAL:
    case BOOLEAN_LITERAL:
    case NULL_LITERAL:
      node = Literal();
        {if (true) return node;}
      break;
    case 111:
      jj_consume_token(111);
      node = Expression();
      jj_consume_token(112);
        {if (true) return node;}
      break;
    case NEW:
      node = AllocationExpression();
        {if (true) return node;}
      break;
    default:
      jj_la1[55] = jj_gen;
      if (jj_2_11(2147483647)) {
        node = ResultType();
        jj_consume_token(109);
        jj_consume_token(CLASS);
        ClassExpression newNode = new ClassExpression();
        newNode.addChild(node);
        node = newNode;
        {if (true) return node;}
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          nameNode = Name();
        nameNode.setCanBeClass(false);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 111:
            argNode = Arguments();
            int index = nameNode.getChildNum() - 1;
            FieldName fName = (FieldName)nameNode.getChild(index);
            nameNode.removeChild(index);
            nameNode.setCanBeClass(true);
            FunctionExpression func = new FunctionExpression();
            func.setFuncName(fName.getFieldName());
            func.addChild(argNode);
            nameNode.addChild(func);
            break;
          default:
            jj_la1[54] = jj_gen;
            ;
          }
        {if (true) return nameNode;}
          break;
        default:
          jj_la1[56] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public ExpressionNode PrimarySuffix() throws ParseException {
    ExpressionNode node, tmpNode;
    ExpressionNode argNode = null;
    Token t;
    if (jj_2_12(2)) {
      jj_consume_token(109);
      tmpNode = AllocationExpression();
            node = new FieldExpression();
            node.addChild(tmpNode);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 115:
        jj_consume_token(115);
        tmpNode = Expression();
        jj_consume_token(116);
            node = new ArrayAccessOperator();
            ArrayExpression arrayNode = new ArrayExpression();
            arrayNode.addChild(tmpNode);
            node.addChild(arrayNode);
        break;
      case 109:
        jj_consume_token(109);
        t = jj_consume_token(IDENTIFIER);
            node = new FieldExpression();
            FieldName fieldName = new FieldName();
            fieldName.setFieldName(t.image);
            node.addChild(fieldName);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 111:
          argNode = Arguments();
                node = new FieldExpression();
                FunctionExpression func = new FunctionExpression();
                func.setFuncName(t.image);
                func.addChild(argNode);
                node.addChild(func);
          break;
        default:
          jj_la1[57] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[58] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
        {if (true) return node;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionNode Literal() throws ParseException {
    Literal node = new Literal();
    Token t;
    String image;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      t = jj_consume_token(INTEGER_LITERAL);
        image = t.image;

        if(image.endsWith("l") || image.endsWith("L"))
        {
            node.setValueClass(long.class);
            image = image.substring(0, image.length() - 1);
            node.setConstantValue(Long.valueOf(image));
        }
        else
        {
            node.setValueClass(int.class);
            node.setConstantValue(Integer.valueOf(image));
        }

        {if (true) return node;}
      break;
    case FLOATING_POINT_LITERAL:
      t = jj_consume_token(FLOATING_POINT_LITERAL);
        image = t.image;
        if(image.endsWith("f") || image.endsWith("F"))
        {
            node.setValueClass(float.class);
            node.setConstantValue(Float.valueOf(image));
        }
        else
        {
            node.setValueClass(double.class);
            node.setConstantValue(Double.valueOf(image));
        }

        {if (true) return node;}
      break;
    case CHARACTER_LITERAL:
      t = jj_consume_token(CHARACTER_LITERAL);
        node.setValueClass(char.class);
        node.setConstantValue(new Character(t.image.charAt(1)));
        {if (true) return node;}
      break;
    case STRING_LITERAL:
      t = jj_consume_token(STRING_LITERAL);
        node.setValueClass(String.class);
        node.setConstantValue(StringUtil.unescape(t.image.substring(1, t.image.length() - 1)));
        {if (true) return node;}
      break;
    case BOOLEAN_LITERAL:
      t = jj_consume_token(BOOLEAN_LITERAL);
        node.setValueClass(boolean.class);
        node.setConstantValue(Boolean.valueOf(t.image));
        {if (true) return node;}
      break;
    case NULL_LITERAL:
      t = jj_consume_token(NULL_LITERAL);
        node.setValueClass(null);
        node.setConstantValue(null);
        {if (true) return node;}
      break;
    default:
      jj_la1[59] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public ExpressionNode Arguments() throws ParseException {
    ExpressionNode node = new Argument();
    ExpressionNode argList;
    jj_consume_token(111);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PRIMITIVETYPE:
    case PLUSMINUS:
    case INCRDECR:
    case NEW:
    case VOID:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case CHARACTER_LITERAL:
    case BOOLEAN_LITERAL:
    case NULL_LITERAL:
    case IDENTIFIER:
    case 111:
    case 130:
    case 131:
      argList = ArgumentList();
            node.addChild(argList);
      break;
    default:
      jj_la1[60] = jj_gen;
      ;
    }
    jj_consume_token(112);
        {if (true) return node;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionNode ArgumentList() throws ParseException {
    ExpressionNode node = new ArgumentList();
    ExpressionNode expr;
    expr = Expression();
        node.addChild(expr);
    label_23:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 114:
        ;
        break;
      default:
        jj_la1[61] = jj_gen;
        break label_23;
      }
      jj_consume_token(114);
      expr = Expression();
            node.addChild(expr);
    }
        {if (true) return node;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionNode AllocationExpression() throws ParseException {
    ExpressionNode node = new AllocationExpression();
    ExpressionNode type, init;
    if (jj_2_13(2)) {
      jj_consume_token(NEW);
      type = PrimitiveType();
      init = ArrayDimsAndInits();
        node.addChild(type);
        node.addChild(init);
        {if (true) return node;}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NEW:
        jj_consume_token(NEW);
        type = Name();
        node.addChild(type);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 111:
          init = Arguments();
            node.addChild(init);
          break;
        case 115:
          init = ArrayDimsAndInits();
            node.addChild(init);
          break;
        default:
          jj_la1[62] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        {if (true) return node;}
        break;
      default:
        jj_la1[63] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

/*
 * The second LOOKAHEAD specification below is to parse to PrimarySuffix
 * if there is an expression between the "[...]".
 */
  final public ExpressionNode ArrayDimsAndInits() throws ParseException {
    ExpressionNode node = new ArrayDimsAndInits();
    ExpressionNode expr, init;
    if (jj_2_16(2)) {
      label_24:
      while (true) {
        jj_consume_token(115);
        expr = Expression();
        jj_consume_token(116);
            ExpressionNode arrayExpr = new ArrayExpression();
            arrayExpr.addChild(expr);
            node.addChild(arrayExpr);
        if (jj_2_14(2)) {
          ;
        } else {
          break label_24;
        }
      }
      label_25:
      while (true) {
        if (jj_2_15(2)) {
          ;
        } else {
          break label_25;
        }
        jj_consume_token(115);
        jj_consume_token(116);
            ExpressionNode arrayExpr = new ArrayExpression();
            node.addChild(arrayExpr);
      }
        {if (true) return node;}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 115:
        label_26:
        while (true) {
          jj_consume_token(115);
          jj_consume_token(116);
            ExpressionNode arrayExpr = new ArrayExpression();
            node.addChild(arrayExpr);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 115:
            ;
            break;
          default:
            jj_la1[64] = jj_gen;
            break label_26;
          }
        }
        init = ArrayInitializer();
        node.addChild(init);
        {if (true) return node;}
        break;
      default:
        jj_la1[65] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public ExpressionNode ArrayInitializer() throws ParseException {
    ExpressionNode node = new ArrayInitExpression();
    ExpressionNode init;
    jj_consume_token(107);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PRIMITIVETYPE:
    case PLUSMINUS:
    case INCRDECR:
    case NEW:
    case VOID:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case CHARACTER_LITERAL:
    case BOOLEAN_LITERAL:
    case NULL_LITERAL:
    case IDENTIFIER:
    case 107:
    case 111:
    case 130:
    case 131:
      init = VariableInitializer();
            node.addChild(init);
      label_27:
      while (true) {
        if (jj_2_17(2)) {
          ;
        } else {
          break label_27;
        }
        jj_consume_token(114);
        init = VariableInitializer();
                node.addChild(init);
      }
      break;
    default:
      jj_la1[66] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 114:
      jj_consume_token(114);
      break;
    default:
      jj_la1[67] = jj_gen;
      ;
    }
    jj_consume_token(113);
        {if (true) return node;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionNode VariableInitializer() throws ParseException {
    ExpressionNode node;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 107:
      node = ArrayInitializer();
        {if (true) return node;}
      break;
    case PRIMITIVETYPE:
    case PLUSMINUS:
    case INCRDECR:
    case NEW:
    case VOID:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case CHARACTER_LITERAL:
    case BOOLEAN_LITERAL:
    case NULL_LITERAL:
    case IDENTIFIER:
    case 111:
    case 130:
    case 131:
      node = Expression();
        {if (true) return node;}
      break;
    default:
      jj_la1[68] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public FieldExpression Name() throws ParseException {
    FieldExpression node = new FieldExpression();
    Token t;
    FieldName fieldName;
    t = jj_consume_token(IDENTIFIER);
        fieldName = new FieldName();
        fieldName.setFieldName(t.image);
        node.addChild(fieldName);
    label_28:
    while (true) {
      if (jj_2_18(2)) {
        ;
      } else {
        break label_28;
      }
      jj_consume_token(109);
      t = jj_consume_token(IDENTIFIER);
            fieldName = new FieldName();
            fieldName.setFieldName(t.image);
            node.addChild(fieldName);
    }
        {if (true) return node;}
    throw new Error("Missing return statement in function");
  }

/*
 * Type, name and expression syntax follows.
 */
  final public ExpressionNode Type() throws ParseException {
    ExpressionNode node = new TypeExpression();
    ExpressionNode name, array;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PRIMITIVETYPE:
      name = PrimitiveType();
      break;
    case IDENTIFIER:
      name = Name();
      break;
    default:
      jj_la1[69] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        node.addChild(name);
    label_29:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 115:
        ;
        break;
      default:
        jj_la1[70] = jj_gen;
        break label_29;
      }
      jj_consume_token(115);
      jj_consume_token(116);
            array = new ArrayExpression();
            node.addChild(array);
    }
        {if (true) return node;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionNode PrimitiveType() throws ParseException {
    ExpressionNode node = new PrimitiveType();
    Token t;
    t = jj_consume_token(PRIMITIVETYPE);
        node.setType(t.image);
        {if (true) return node;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionNode ResultType() throws ParseException {
    ExpressionNode node;
    Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VOID:
      t = jj_consume_token(VOID);
            node = new PrimitiveType();
            node.setType(t.image);
      break;
    case PRIMITIVETYPE:
    case IDENTIFIER:
      node = Type();
      break;
    default:
      jj_la1[71] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return node;}
    throw new Error("Missing return statement in function");
  }

  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  final private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  final private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  final private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  final private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  final private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  final private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  final private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  final private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  final private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  final private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  final private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  final private boolean jj_2_13(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_13(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(12, xla); }
  }

  final private boolean jj_2_14(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_14(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(13, xla); }
  }

  final private boolean jj_2_15(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_15(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(14, xla); }
  }

  final private boolean jj_2_16(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_16(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(15, xla); }
  }

  final private boolean jj_2_17(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_17(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(16, xla); }
  }

  final private boolean jj_2_18(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_18(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(17, xla); }
  }

  final private boolean jj_3_14() {
    if (jj_scan_token(115)) return true;
    if (jj_3R_39()) return true;
    return false;
  }

  final private boolean jj_3R_31() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(110)) return true;
    return false;
  }

  final private boolean jj_3R_47() {
    if (jj_scan_token(115)) return true;
    if (jj_3R_39()) return true;
    return false;
  }

  final private boolean jj_3_16() {
    Token xsp;
    if (jj_3_14()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_14()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_68() {
    if (jj_3R_69()) return true;
    return false;
  }

  final private boolean jj_3R_79() {
    if (jj_scan_token(INCRDECR)) return true;
    return false;
  }

  final private boolean jj_3_12() {
    if (jj_scan_token(109)) return true;
    if (jj_3R_38()) return true;
    return false;
  }

  final private boolean jj_3R_36() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_12()) {
    jj_scanpos = xsp;
    if (jj_3R_47()) {
    jj_scanpos = xsp;
    if (jj_3R_48()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_78() {
    if (jj_3R_80()) return true;
    return false;
  }

  final private boolean jj_3R_77() {
    if (jj_3R_79()) return true;
    return false;
  }

  final private boolean jj_3R_50() {
    if (jj_3R_32()) return true;
    return false;
  }

  final private boolean jj_3R_76() {
    if (jj_scan_token(PLUSMINUS)) return true;
    return false;
  }

  final private boolean jj_3R_67() {
    if (jj_3R_68()) return true;
    return false;
  }

  final private boolean jj_3R_49() {
    if (jj_scan_token(VOID)) return true;
    return false;
  }

  final private boolean jj_3R_75() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_76()) {
    jj_scanpos = xsp;
    if (jj_3R_77()) {
    jj_scanpos = xsp;
    if (jj_3R_78()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_51() {
    if (jj_scan_token(NEW)) return true;
    return false;
  }

  final private boolean jj_3R_37() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_49()) {
    jj_scanpos = xsp;
    if (jj_3R_50()) return true;
    }
    return false;
  }

  final private boolean jj_3_3() {
    if (jj_scan_token(109)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3_11() {
    if (jj_3R_37()) return true;
    if (jj_scan_token(109)) return true;
    if (jj_scan_token(CLASS)) return true;
    return false;
  }

  final private boolean jj_3R_94() {
    if (jj_3R_35()) return true;
    return false;
  }

  final private boolean jj_3R_38() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_13()) {
    jj_scanpos = xsp;
    if (jj_3R_51()) return true;
    }
    return false;
  }

  final private boolean jj_3_13() {
    if (jj_scan_token(NEW)) return true;
    if (jj_3R_34()) return true;
    return false;
  }

  final private boolean jj_3R_34() {
    if (jj_scan_token(PRIMITIVETYPE)) return true;
    return false;
  }

  final private boolean jj_3R_66() {
    if (jj_3R_67()) return true;
    return false;
  }

  final private boolean jj_3R_93() {
    if (jj_3R_37()) return true;
    return false;
  }

  final private boolean jj_3R_74() {
    if (jj_3R_75()) return true;
    return false;
  }

  final private boolean jj_3R_92() {
    if (jj_3R_38()) return true;
    return false;
  }

  final private boolean jj_3_5() {
    if (jj_3R_32()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3R_44() {
    if (jj_scan_token(115)) return true;
    if (jj_scan_token(116)) return true;
    return false;
  }

  final private boolean jj_3R_91() {
    if (jj_scan_token(111)) return true;
    return false;
  }

  final private boolean jj_3R_43() {
    if (jj_3R_35()) return true;
    return false;
  }

  final private boolean jj_3R_42() {
    if (jj_3R_34()) return true;
    return false;
  }

  final private boolean jj_3R_90() {
    if (jj_3R_58()) return true;
    return false;
  }

  final private boolean jj_3R_89() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_90()) {
    jj_scanpos = xsp;
    if (jj_3R_91()) {
    jj_scanpos = xsp;
    if (jj_3R_92()) {
    jj_scanpos = xsp;
    if (jj_3R_93()) {
    jj_scanpos = xsp;
    if (jj_3R_94()) return true;
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3_4() {
    if (jj_3R_32()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3R_32() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_42()) {
    jj_scanpos = xsp;
    if (jj_3R_43()) return true;
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_44()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_59() {
    if (jj_3R_66()) return true;
    return false;
  }

  final private boolean jj_3R_73() {
    if (jj_3R_74()) return true;
    return false;
  }

  final private boolean jj_3_10() {
    if (jj_3R_36()) return true;
    return false;
  }

  final private boolean jj_3R_55() {
    if (jj_3R_58()) return true;
    return false;
  }

  final private boolean jj_3R_88() {
    if (jj_3R_89()) return true;
    return false;
  }

  final private boolean jj_3_18() {
    if (jj_scan_token(109)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3R_56() {
    if (jj_3R_59()) return true;
    return false;
  }

  final private boolean jj_3R_65() {
    if (jj_scan_token(NULL_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_72() {
    if (jj_3R_73()) return true;
    return false;
  }

  final private boolean jj_3_2() {
    if (jj_3R_31()) return true;
    return false;
  }

  final private boolean jj_3R_64() {
    if (jj_scan_token(BOOLEAN_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_35() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_18()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_85() {
    if (jj_3R_88()) return true;
    return false;
  }

  final private boolean jj_3R_41() {
    if (jj_3R_37()) return true;
    return false;
  }

  final private boolean jj_3R_63() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_54() {
    if (jj_3R_39()) return true;
    return false;
  }

  final private boolean jj_3R_62() {
    if (jj_scan_token(CHARACTER_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_52() {
    if (jj_3R_56()) return true;
    return false;
  }

  final private boolean jj_3R_40() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_53()) {
    jj_scanpos = xsp;
    if (jj_3R_54()) return true;
    }
    return false;
  }

  final private boolean jj_3R_53() {
    if (jj_3R_57()) return true;
    return false;
  }

  final private boolean jj_3R_87() {
    if (jj_scan_token(111)) return true;
    return false;
  }

  final private boolean jj_3_9() {
    if (jj_scan_token(111)) return true;
    if (jj_3R_34()) return true;
    return false;
  }

  final private boolean jj_3R_71() {
    if (jj_3R_72()) return true;
    return false;
  }

  final private boolean jj_3_17() {
    if (jj_scan_token(114)) return true;
    if (jj_3R_40()) return true;
    return false;
  }

  final private boolean jj_3R_86() {
    if (jj_scan_token(111)) return true;
    return false;
  }

  final private boolean jj_3R_84() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_86()) {
    jj_scanpos = xsp;
    if (jj_3R_87()) return true;
    }
    return false;
  }

  final private boolean jj_3R_61() {
    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3_8() {
    if (jj_scan_token(111)) return true;
    if (jj_3R_35()) return true;
    if (jj_scan_token(115)) return true;
    return false;
  }

  final private boolean jj_3R_30() {
    if (jj_3R_41()) return true;
    return false;
  }

  final private boolean jj_3_1() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_30()) jj_scanpos = xsp;
    if (jj_scan_token(107)) return true;
    return false;
  }

  final private boolean jj_3R_39() {
    if (jj_3R_52()) return true;
    return false;
  }

  final private boolean jj_3R_46() {
    if (jj_scan_token(111)) return true;
    if (jj_3R_35()) return true;
    if (jj_scan_token(112)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(130)) {
    jj_scanpos = xsp;
    if (jj_scan_token(131)) {
    jj_scanpos = xsp;
    if (jj_scan_token(111)) {
    jj_scanpos = xsp;
    if (jj_scan_token(104)) {
    jj_scanpos = xsp;
    if (jj_scan_token(22)) {
    jj_scanpos = xsp;
    if (jj_3R_55()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_45() {
    if (jj_scan_token(111)) return true;
    if (jj_3R_35()) return true;
    if (jj_scan_token(115)) return true;
    if (jj_scan_token(116)) return true;
    return false;
  }

  final private boolean jj_3R_57() {
    if (jj_scan_token(107)) return true;
    return false;
  }

  final private boolean jj_3R_70() {
    if (jj_3R_71()) return true;
    return false;
  }

  final private boolean jj_3R_33() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_7()) {
    jj_scanpos = xsp;
    if (jj_3R_45()) {
    jj_scanpos = xsp;
    if (jj_3R_46()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3_7() {
    if (jj_scan_token(111)) return true;
    if (jj_3R_34()) return true;
    return false;
  }

  final private boolean jj_3_6() {
    if (jj_3R_33()) return true;
    return false;
  }

  final private boolean jj_3R_58() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_60()) {
    jj_scanpos = xsp;
    if (jj_3R_61()) {
    jj_scanpos = xsp;
    if (jj_3R_62()) {
    jj_scanpos = xsp;
    if (jj_3R_63()) {
    jj_scanpos = xsp;
    if (jj_3R_64()) {
    jj_scanpos = xsp;
    if (jj_3R_65()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_60() {
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_83() {
    if (jj_3R_85()) return true;
    return false;
  }

  final private boolean jj_3R_82() {
    if (jj_3R_84()) return true;
    return false;
  }

  final private boolean jj_3R_69() {
    if (jj_3R_70()) return true;
    return false;
  }

  final private boolean jj_3R_81() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(130)) {
    jj_scanpos = xsp;
    if (jj_scan_token(131)) return true;
    }
    return false;
  }

  final private boolean jj_3_15() {
    if (jj_scan_token(115)) return true;
    if (jj_scan_token(116)) return true;
    return false;
  }

  final private boolean jj_3R_80() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_81()) {
    jj_scanpos = xsp;
    if (jj_3R_82()) {
    jj_scanpos = xsp;
    if (jj_3R_83()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_48() {
    if (jj_scan_token(109)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  public ParserTokenManager token_source;
  JavaCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[72];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static private int[] jj_la1_4;
  static {
      jj_la1_0();
      jj_la1_1();
      jj_la1_2();
      jj_la1_3();
      jj_la1_4();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x0,0x0,0x2512000,0x2002000,0x2502000,0x0,0x0,0x1100000,0x1100000,0x2502000,0x0,0x2502000,0x0,0x0,0x2502000,0x2512000,0x2502000,0x2502000,0x0,0x0,0x0,0x2512000,0x0,0x0,0x2502000,0x2502000,0x0,0x1000000,0x0,0x1000000,0x0,0x2000,0x0,0x1000000,0x0,0x80000000,0x40000000,0x20000000,0x8000000,0x10000000,0x4000,0x800000,0x8000,0x200000,0x10000,0x20000,0x2512000,0x0,0x0,0x2402000,0x400000,0x0,0x0,0x100000,0x0,0x400000,0x0,0x0,0x0,0x0,0x2512000,0x0,0x0,0x400000,0x0,0x0,0x2512000,0x0,0x2512000,0x2000,0x0,0x2002000,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x0,0x0,0xd1000000,0x0,0xd1000000,0x0,0x0,0x0,0x0,0xd1000000,0x0,0xd1000000,0x0,0x0,0xd1000000,0xd1000000,0xd1000000,0xd1000000,0x0,0x0,0x0,0xd1000000,0x0,0x0,0xd1000000,0xd1000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd1000000,0x0,0x0,0xd1000000,0xd1000000,0x0,0x0,0x0,0x0,0xd1000000,0x0,0x0,0x0,0xd1000000,0xd1000000,0x0,0x0,0x0,0x0,0x0,0xd1000000,0x0,0xd1000000,0x0,0x0,0x0,};
   }
   private static void jj_la1_2() {
      jj_la1_2 = new int[] {0x100000,0x0,0x3,0x0,0x8805051b,0x0,0x0,0x0,0x0,0x3,0x220,0x8805051b,0x220,0x800,0x3,0x3,0x3,0x3,0x0,0x0,0x0,0x3,0x40,0x8000,0x8805051b,0x8805051b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x3,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x3,0x3,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x3,0x0,0x0,0x0,};
   }
   private static void jj_la1_3() {
      jj_la1_3 = new int[] {0x0,0x1000,0x8100,0x100,0x99a4,0x2000,0x4000,0xffe00000,0xffe00000,0x8100,0x0,0x99a4,0x0,0x0,0x8100,0x8100,0x8100,0x8100,0x40000,0x100,0x100,0x8100,0x0,0x0,0x99a4,0x99a4,0x40000,0x0,0x80000,0xffe00000,0x40000,0x100,0x0,0xffe00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8100,0x0,0x0,0x8100,0x8100,0x8000,0x8000,0x0,0x8000,0x8000,0x100,0x8000,0x82000,0x0,0x8100,0x40000,0x88000,0x0,0x80000,0x80000,0x8900,0x40000,0x8900,0x100,0x80000,0x100,};
   }
   private static void jj_la1_4() {
      jj_la1_4 = new int[] {0x0,0x0,0xc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc,0x0,0x0,0x0,0x0,0x0,0xc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc,0xc,0xc,0x0,0xc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc,0x0,0x0,0x0,0x0,0x0,0xc,0x0,0xc,0x0,0x0,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[18];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  public Parser(java.io.InputStream stream) {
     this(stream, null);
  }
  public Parser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 72; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 72; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public Parser(java.io.Reader stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 72; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 72; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public Parser(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 72; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 72; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
        int[] oldentry = (int[])(e.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.addElement(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[132];
    for (int i = 0; i < 132; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 72; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
          if ((jj_la1_4[i] & (1<<j)) != 0) {
            la1tokens[128+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 132; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

  final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 18; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
            case 12: jj_3_13(); break;
            case 13: jj_3_14(); break;
            case 14: jj_3_15(); break;
            case 15: jj_3_16(); break;
            case 16: jj_3_17(); break;
            case 17: jj_3_18(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
