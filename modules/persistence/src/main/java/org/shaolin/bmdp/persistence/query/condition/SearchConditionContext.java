package org.shaolin.bmdp.persistence.query.condition;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.shaolin.bmdp.datamodel.common.TargetEntityType;
import org.shaolin.bmdp.datamodel.common.VariableType;
import org.shaolin.bmdp.datamodel.rdbdiagram.ConditionFieldMappingType;
import org.shaolin.bmdp.datamodel.rdbdiagram.SearchConditionMappingType;
import org.shaolin.bmdp.persistence.InvalidSearchQueryException;
import org.shaolin.bmdp.persistence.query.generator.QueryExpressionNodeList;
import org.shaolin.bmdp.persistence.query.generator.QueryParser;
import org.shaolin.bmdp.persistence.query.generator.SearchQuery;
import org.shaolin.bmdp.persistence.query.generator.SearchQueryEvaluationContext;
import org.shaolin.bmdp.persistence.query.generator.SearchQueryParsingContext;
import org.shaolin.bmdp.persistence.query.generator.SearchQueryUtil;
import org.shaolin.bmdp.persistence.query.operator.LogicalOperator;
import org.shaolin.bmdp.runtime.VariableUtil;
import org.shaolin.javacc.exception.EvaluationException;
import org.shaolin.javacc.sql.exception.QueryParsingException;

/**
 * The Class representing a search query condition runtime object It provides
 * the functions: 1.generating search condition filter for searching result data
 * 2.validate the constraint search result 3.getting compatible search condition
 * data
 * 
 */
public class SearchConditionContext {
	
	boolean isDistinct;
	
	/* search condition definition */
	// private SearchConditionMappingType searchConditionMapping;

	private String[] searchConditionVarNames;

	/*
	 * all search condition filter generated by the field mapping of the search
	 * condition definition list of SearchConditionFilter object
	 */
	private List<ISearchConditionFilter> searchConditionFilters
		= new ArrayList<ISearchConditionFilter>();

	/*
	 * the condition filter generated by the link field mapping of the search
	 * condition definition
	 */
	private QueryExpressionNodeList joinConditionFilterExpression;

	/*
	 * used for search of condition data all query from strings generated by
	 * search condition data
	 */
	private List<String> queryFromList = new ArrayList<String>();

	/*
	 * used for search of condition data all query select strings generated by
	 * search condition data
	 */
	private List<String> selectList = new ArrayList<String>();
	
	/*
	 * default condition objects.
	 */
	private final List<Map<String, Object>> defaultConditionObjects = new ArrayList<Map<String, Object>>(1);

	private final SearchConditionMappingType searchConditionMapping;
	
	private SearchQuery basicQuery;
	
	public SearchConditionContext(
			SearchConditionMappingType searchConditionMapping,
			SearchQueryParsingContext totalParsingContext, boolean isDistinct)
			throws InvalidSearchQueryException {
		this.isDistinct = isDistinct;
		this.searchConditionMapping = searchConditionMapping;
		
		initSearchConditionFilters(searchConditionMapping, totalParsingContext);
	}

	/**
	 * init the search condition context
	 * 
	 * @param searchConditionMapping
	 * @param totalParsingContext
	 * @throws InvalidSearchQueryException
	 */
	private void initSearchConditionFilters(
			SearchConditionMappingType searchConditionMapping,
			SearchQueryParsingContext totalParsingContext)
			throws InvalidSearchQueryException {
		searchConditionFilters.clear();

		SearchQueryParsingContext parsingContext = new SearchQueryParsingContext(
				totalParsingContext.getVariableTypes());
		parsingContext.setUseParamBinding(totalParsingContext
				.getUseParamBinding());

		// 1. build reverse query and parsing context
		queryFromList.clear();
		selectList.clear();
		List<VariableType> searchConditionVariables = searchConditionMapping
				.getSearchConditionDatas();
		searchConditionVarNames = new String[searchConditionVariables.size()];
		
		Map<String, Object> conditionObjects = new HashMap<String, Object>();
		defaultConditionObjects.clear();
		defaultConditionObjects.add(conditionObjects);
		for (int i = 0; i < searchConditionVariables.size(); i++) {
			VariableType searchConditionVariable = searchConditionVariables
					.get(i);
			String searchConditionVarName = searchConditionVariable.getName();
			searchConditionVarNames[i] = searchConditionVarName;
			TargetEntityType type = searchConditionVariable.getType();
			
			Class clazzType = VariableUtil.getVariableClass(searchConditionVariable);
			Object defaultValue = VariableUtil.createVariableObject(searchConditionVariable);
			parsingContext.setVariableClass(searchConditionVarName,clazzType);
			conditionObjects.put(searchConditionVarName, defaultValue);

			String fromString = type.getEntityName() + " as "
					+ searchConditionVarName;
			queryFromList.add(fromString);
//			selectList.add(searchConditionVarName
//					+ SearchQueryUtil.OQLFIELDSEPERATOR
//					+ SearchQueryUtil.OIDFIELD);
		}
		
		// 2. build condition field context
		List<ConditionFieldMappingType> searchConditionFieldMappings = searchConditionMapping
				.getFieldMappings();
		for (ConditionFieldMappingType mapping : searchConditionFieldMappings) {
			ISearchConditionFilter conditionFilter = SearchConditionFilterFactory
					.createSearchConditionFilter(mapping, parsingContext);
			searchConditionFilters.add(conditionFilter);
		}

		// 3. build link join condition filter
		joinConditionFilterExpression = null;
		/**
		List<ConditionFieldMappingType> linkConditionFieldMappings = searchConditionMapping
				.getLinkFieldMapping();
		for (ConditionFieldMappingType mapping : linkConditionFieldMappings) {
			ISearchConditionFilter conditionFilter = SearchConditionFilterFactory
					.createSearchConditionFilter(mapping, parsingContext);
			QueryExpressionNodeList conditionExpression = conditionFilter
					.getStaticFilterExpression();
			joinConditionFilterExpression = SearchQueryUtil
					.appendExpressionNodeList(joinConditionFilterExpression,
							conditionExpression, LogicalOperator.AND);
		}
		*/
	}
	
	public void setSearchQuery(SearchQuery basicQuery) {
		this.basicQuery = basicQuery;
	}
	
	public String getDefaultInputParams() {
		StringBuffer sb = new StringBuffer();
		List<VariableType> searchConditionVariables = searchConditionMapping
				.getSearchConditionDatas();
		for (int i = 0; i < searchConditionVariables.size(); i++) {
			VariableType searchConditionVariable = searchConditionVariables
					.get(i);
			String searchConditionVarName = searchConditionVariable.getName();
			Class clazzType = VariableUtil.getVariableClass(searchConditionVariable);

			sb.append(clazzType.getName());
			sb.append(" ").append(searchConditionVarName);
			sb.append(",");
			
		}
		sb.deleteCharAt(sb.length()-1);
		return sb.toString();
	}
	
	public List<Map<String, Object>> getDefaultConditionObjects() {
		return defaultConditionObjects;
	}
	
	public String getConditionDefinition() {
		SearchQueryEvaluationContext context = new SearchQueryEvaluationContext();
		for (int i = 0, n = defaultConditionObjects.size(); i < n; i++) {
			Object searchConditionObject = defaultConditionObjects.get(i);
			buildEvaluationContext(context, searchConditionObject);
		}
		
		QueryParser parser = basicQuery.getParser(); 
		StringBuffer sb = new StringBuffer();
		sb.append("        ArrayList<Object> parameters = new ArrayList<Object>();\n");
		for (ISearchConditionFilter conditionFilter : searchConditionFilters) {
			try {
				boolean isComposited = false;
				if (conditionFilter instanceof CompositeSearchConditionFilter) {
					isComposited = true;
				} 
				sb.append(conditionFilter.getConditionExpressionCode(parser, context, isComposited));
			} catch (QueryParsingException e) {
				e.printStackTrace();
				sb.append("        String error =\"Error expression\";\n");
			}
		}
		
		return sb.toString();
	}
	
	/**
	 * Generate the query filter by default search condition objects.
	 * 
	 * @return
	 */
	public QueryExpressionNodeList getDefaultSearchConditionFilter() {
		return getSearchConditionFilter(defaultConditionObjects);
	}
	
	/**
	 * Generate the query filter with the search condition objects
	 * 
	 * @param searchConditionObjects
	 *            list of map(Key: search condition data name, Value: search
	 *            condition data)
	 * @return the generated filter
	 */
	public QueryExpressionNodeList getSearchConditionFilter(
			List searchConditionObjects) {
		QueryExpressionNodeList totalFilter = null;

		SearchQueryEvaluationContext context = new SearchQueryEvaluationContext();

		for (int i = 0, n = searchConditionObjects.size(); i < n; i++) {
			// init evaluation context
			Object searchConditionObject = searchConditionObjects.get(i);
			buildEvaluationContext(context, searchConditionObject);

			// get one round filter
			QueryExpressionNodeList searchExpression = getSearchExpression(context);

			// make final query filter using the OR operator
			totalFilter = SearchQueryUtil.appendExpressionNodeList(totalFilter,
					searchExpression, LogicalOperator.OR);
		}

		// finally make the join filter using the AND operator
		totalFilter = SearchQueryUtil.appendExpressionNodeList(totalFilter,
				joinConditionFilterExpression, LogicalOperator.AND);

		return totalFilter;
	}

	/**
	 * build one round query filter
	 * 
	 * @param context
	 * @return the query filter
	 */
	private QueryExpressionNodeList getSearchExpression(
			SearchQueryEvaluationContext context) {
		QueryExpressionNodeList searchExpression = null;

		// iterator every search condition, build filter using AND operator
		for (ISearchConditionFilter conditionFilter : searchConditionFilters) {
			QueryExpressionNodeList conditionExpression = conditionFilter
					.getSearchConditionExpression(context);
			searchExpression = SearchQueryUtil.appendExpressionNodeList(
					searchExpression, conditionExpression, LogicalOperator.AND);
		}

		return searchExpression;
	}

	/**
	 * @param searchConditionObjects
	 * @param validateObjectList
	 * @return
	 */
	public boolean validateSearchQueryResult(String searchResultVarName,
			List searchConditionObjects, Object validateObject) {
		boolean isValidate = false;

		if (searchConditionFilters.size() == 0) {
			isValidate = true;
		} else {
			SearchQueryEvaluationContext context = new SearchQueryEvaluationContext();

			try {
				context.setVariableValue(searchResultVarName, validateObject);
			} catch (EvaluationException ex) {
				// probably won't happen
			}

			for (int j = 0, m = searchConditionObjects.size(); j < m; j++) {
				Object searchConditionObject = searchConditionObjects.get(j);
				buildEvaluationContext(context, searchConditionObject);

				for (int k = 0, l = searchConditionFilters.size(); k < l; k++) {
					ISearchConditionFilter conditionFilter = (ISearchConditionFilter) searchConditionFilters
							.get(k);
					isValidate = conditionFilter
							.validateSearchQueryResult(context);
					if (!isValidate) {
						break;
					}
				}

				if (isValidate) {
					break;
				}
			}
		}

		return isValidate;
	}

	public void buildEvaluationContext(SearchQueryEvaluationContext context,
			Object searchConditionObject) {
		try {
			if (searchConditionObject instanceof Map) {
				Map varMap = (Map) searchConditionObject;
				for (Iterator iter = varMap.entrySet().iterator(); iter
						.hasNext();) {
					Map.Entry entry = (Map.Entry) iter.next();
					String searchConditionVarName = (String) entry.getKey();
					context.setVariableValue(searchConditionVarName,
							entry.getValue());
				}
			} else {
				String searchConditionVarName = searchConditionVarNames[0];
				context.setVariableValue(searchConditionVarName,
						searchConditionObject);
			}
		} catch (EvaluationException ex) {
			// probably won't happen
		}
	}

}
